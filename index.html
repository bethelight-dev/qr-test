<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BE THE LIGHT - –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∏ –°–∫–∞–Ω–µ—Ä v2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            min-height: 100vh;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #b19cd9;
            margin-bottom: 5px;
            font-size: 32px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .version {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-bottom: 5px;
            font-family: 'Courier New', monospace;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .tab {
            padding: 12px 30px;
            background: #2a2a2a;
            border: 2px solid #b19cd9;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .tab.active {
            background: #b19cd9;
            color: #1a1a1a;
        }

        .tab:hover {
            transform: translateY(-2px);
        }

        .panel {
            display: none;
            background: #2a2a2a;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(177, 156, 217, 0.3);
        }

        .panel.active {
            display: block;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #b19cd9;
            font-weight: 600;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #444;
            border-radius: 8px;
            font-size: 16px;
            background: #1a1a1a;
            color: white;
            transition: border-color 0.3s;
        }

        input:focus, textarea:focus {
            outline: none;
            border-color: #b19cd9;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .control {
            display: flex;
            flex-direction: column;
        }

        select, input[type="number"], input[type="file"], input[type="checkbox"] {
            padding: 10px;
            border: 2px solid #444;
            border-radius: 8px;
            font-size: 14px;
            background: #1a1a1a;
            color: white;
            cursor: pointer;
        }

        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #b19cd9 0%, #8b7ab8 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            margin-bottom: 20px;
        }

        button:hover {
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        #output {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 400px;
            position: relative;
        }

        #canvas {
            border-radius: 50%;
            box-shadow: 0 10px 40px rgba(177, 156, 217, 0.5);
            max-width: 100%;
        }

        .info {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 14px;
            color: #888;
            border-left: 4px solid #b19cd9;
        }

        #video {
            width: 100%;
            max-width: 500px;
            border-radius: 20px;
            margin: 0 auto;
            display: block;
        }

        .scanner-container {
            text-align: center;
        }

        .scanner-result {
            margin-top: 20px;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 10px;
            text-align: center;
        }

        .scanner-result.success {
            border: 2px solid #4caf50;
        }

        .scanner-result.error {
            border: 2px solid #f44336;
        }

        .result-text {
            font-size: 18px;
            margin-top: 10px;
            word-break: break-all;
        }

        .download-btn {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        }

        canvas#scanCanvas {
            max-width: 100%;
            margin-top: 20px;
            border-radius: 10px;
            display: none;
        }

        canvas#scanCanvas.show {
            display: block;
        }

        .color-picker {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        .grid-size-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .progress {
            margin-top: 20px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 8px;
            text-align: center;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #b19cd9 0%, #8b7ab8 100%);
            transition: width 0.3s;
        }

        .scan-options {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .scan-options button {
            flex: 1;
        }

        .debug-info {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            max-width: 350px;
            border: 1px solid #0f0;
            box-shadow: 0 0 10px rgba(0,255,0,0.3);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        .distribution-info {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>BE THE LIGHT</h1>
        <div class="version">v3.2.0 - Smart Encoding</div>
        <div class="subtitle">–£–º–Ω–æ–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –∑–∞–≥–æ–ª–æ–≤–∫–æ–º –¥–ª–∏–Ω—ã –∏ –ø—Å–µ–≤–¥–æ-—Ç–æ—á–∫–∞–º–∏</div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('generator')">üé® –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä</div>
            <div class="tab" onclick="switchTab('scanner')">üì± –°–∫–∞–Ω–µ—Ä</div>
        </div>

        <!-- –ü–∞–Ω–µ–ª—å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ -->
        <div id="generator" class="panel active">
            <div class="input-group">
                <label for="data">–î–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è:</label>
                <textarea id="data" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç, URL –∏–ª–∏ –ª—é–±—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é...">Hello World!</textarea>
            </div>

            <div class="controls">
                <div class="control">
                    <label for="gridSize">–†–∞–∑–º–µ—Ä —Å–µ—Ç–∫–∏:</label>
                    <select id="gridSize">
                        <option value="16">16√ó8 (–º–∞–ª—ã–π)</option>
                        <option value="20" selected>20√ó10 (—Å—Ä–µ–¥–Ω–∏–π)</option>
                        <option value="24">24√ó12 (–±–æ–ª—å—à–æ–π)</option>
                        <option value="28">28√ó14 (–æ—á–µ–Ω—å –±–æ–ª—å—à–æ–π)</option>
                    </select>
                    <div class="grid-size-info">–®–∏—Ä–∏–Ω–∞ √ó –í—ã—Å–æ—Ç–∞ (–≤–µ—Ä—Ö+–Ω–∏–∑)</div>
                </div>

                <div class="control">
                    <label for="distributionMode">–†–µ–∂–∏–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è:</label>
                    <select id="distributionMode">
                        <option value="split">–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ 50/50</option>
                        <option value="interleave" selected>–ß–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ</option>
                        <option value="zigzag">–ó–∏–≥–∑–∞–≥</option>
                    </select>
                </div>

                <div class="control">
                    <label for="dotMinSize">–ú–∏–Ω. —Ä–∞–∑–º–µ—Ä —Ç–æ—á–∫–∏:</label>
                    <input type="number" id="dotMinSize" value="3" min="2" max="8">
                </div>

                <div class="control">
                    <label for="dotMaxSize">–ú–∞–∫—Å. —Ä–∞–∑–º–µ—Ä —Ç–æ—á–∫–∏:</label>
                    <input type="number" id="dotMaxSize" value="6" min="3" max="12">
                </div>

                <div class="control">
                    <label>–¶–≤–µ—Ç —Ñ–æ–Ω–∞:</label>
                    <div class="color-picker">
                        <input type="color" id="bgColor" value="#b19cd9">
                        <input type="text" id="bgColorText" value="#b19cd9" placeholder="#b19cd9" style="width: 100px; margin-left: 5px;">
                    </div>
                </div>

                <div class="control">
                    <label>–¶–≤–µ—Ç —Ç–æ—á–µ–∫:</label>
                    <div class="color-picker">
                        <input type="color" id="dotColor" value="#ffffff">
                        <input type="text" id="dotColorText" value="#ffffff" placeholder="#ffffff" style="width: 100px; margin-left: 5px;">
                    </div>
                </div>

                <div class="control">
                    <label for="textSize">–†–∞–∑–º–µ—Ä —Ç–µ–∫—Å—Ç–∞:</label>
                    <input type="number" id="textSize" value="42" min="20" max="80">
                </div>

                <div class="control">
                    <label>
                        <div class="checkbox-group">
                            <input type="checkbox" id="showGrid">
                            <span>–ü–æ–∫–∞–∑–∞—Ç—å —Å–µ—Ç–∫—É</span>
                        </div>
                    </label>
                </div>

                <div class="control">
                    <label>
                        <div class="checkbox-group">
                            <input type="checkbox" id="showDebug" checked>
                            <span>–ü–æ–∫–∞–∑–∞—Ç—å –æ—Ç–ª–∞–¥–∫—É</span>
                        </div>
                    </label>
                </div>
            </div>

            <button onclick="generate()">‚ú® –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥</button>

            <div id="output">
                <canvas id="canvas"></canvas>
            </div>

            <div id="distributionInfo" class="distribution-info" style="display: none;"></div>

            <button class="download-btn" onclick="download()" style="display: none;" id="downloadBtn">
                üì• –°–∫–∞—á–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            </button>

            <div class="info">
                <strong>üí° –£–ª—É—á—à–µ–Ω–∏—è v3.2:</strong><br>
                ‚Ä¢ üìè –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å –¥–ª–∏–Ω–æ–π –¥–∞–Ω–Ω—ã—Ö (16 –±–∏—Ç)<br>
                ‚Ä¢ üé≤ –ü—Å–µ–≤–¥–æ-—Å–ª—É—á–∞–π–Ω—ã–µ —Ç–æ—á–∫–∏ –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è (~65%)<br>
                ‚Ä¢ üîÑ –¢—Ä–∏ —Ä–µ–∂–∏–º–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö<br>
                ‚Ä¢ üéØ –ï–¥–∏–Ω–∞—è —Å–µ—Ç–∫–∞ –ø–æ –≤—Å–µ–º—É –∫—Ä—É–≥—É<br>
                ‚Ä¢ üìä –¢–æ—á–Ω–æ–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ –¥–ª–∏–Ω–µ –¥–∞–Ω–Ω—ã—Ö<br>
                ‚Ä¢ üåê –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –∑–æ–Ω (–≤–µ—Ä—Ö, –Ω–∏–∑, –±–æ–∫–∞)<br>
                <br>
                <strong>üìê –°—Ç—Ä—É–∫—Ç—É—Ä–∞:</strong><br>
                ‚Ä¢ –ï–¥–∏–Ω–∞—è —Å–µ—Ç–∫–∞ –ø–æ–∫—Ä—ã–≤–∞–µ—Ç –≤–µ—Å—å –∫—Ä—É–≥<br>
                ‚Ä¢ –í–µ—Ä—Ö –∏ –Ω–∏–∑ - —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ + –ø—Å–µ–≤–¥–æ-–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ<br>
                ‚Ä¢ –ë–æ–∫–∞ - –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω–æ–µ –ø—Å–µ–≤–¥–æ-–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ
            </div>
        </div>

        <!-- –ü–∞–Ω–µ–ª—å —Å–∫–∞–Ω–µ—Ä–∞ -->
        <div id="scanner" class="panel">
            <div class="scan-options">
                <button onclick="startCamera()">üì∑ –ö–∞–º–µ—Ä–∞</button>
                <button onclick="document.getElementById('fileInput').click()">üñºÔ∏è –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ</button>
            </div>
            
            <input type="file" id="fileInput" accept="image/*" style="display: none;" onchange="handleFileUpload(event)">

            <div class="scanner-container">
                <video id="video" autoplay playsinline style="display: none;"></video>
                <canvas id="scanCanvas"></canvas>
            </div>

            <div id="scanProgress"></div>
            <div id="scanResult"></div>

            <div class="info">
                <strong>üì± –ö–∞–∫ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å:</strong><br>
                <strong>–í–∞—Ä–∏–∞–Ω—Ç 1 - –ö–∞–º–µ—Ä–∞:</strong> –ù–∞–∂–º–∏—Ç–µ "–ö–∞–º–µ—Ä–∞" –∏ –Ω–∞–≤–µ–¥–∏—Ç–µ –Ω–∞ –∫–æ–¥<br>
                <strong>–í–∞—Ä–∏–∞–Ω—Ç 2 - –§–æ—Ç–æ:</strong> –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–æ—Ç–æ –∫–æ–¥–∞<br>
                ‚Ä¢ –°–∏—Å—Ç–µ–º–∞ –Ω–∞–π–¥–µ—Ç –∫—Ä—É–≥–ª—ã–µ –º–∞—Ä–∫–µ—Ä—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏<br>
                ‚Ä¢ –î–µ–∫–æ–¥–∏—Ä—É–µ—Ç —Ç–æ—á–∫–∏ –≤ –≤–µ—Ä—Ö–Ω–µ–π –∏ –Ω–∏–∂–Ω–µ–π –∑–æ–Ω–∞—Ö<br>
                ‚Ä¢ –£—á–∏—Ç—ã–≤–∞–µ—Ç —Ä–µ–∂–∏–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
            </div>
        </div>
    </div>

    <div id="debugInfo" class="debug-info" style="display: none;"></div>

    <script>
        let currentCode = null;
        let stream = null;
        let scanning = false;
        let captureInterval = null;

        // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–∞
        document.getElementById('bgColor').addEventListener('input', (e) => {
            document.getElementById('bgColorText').value = e.target.value;
        });
        
        document.getElementById('bgColorText').addEventListener('input', (e) => {
            const color = e.target.value;
            if (/^#[0-9A-F]{6}$/i.test(color)) {
                document.getElementById('bgColor').value = color;
            }
        });

        // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Ü–≤–µ—Ç–∞ —Ç–æ—á–µ–∫
        document.getElementById('dotColor').addEventListener('input', (e) => {
            document.getElementById('dotColorText').value = e.target.value;
        });
        
        document.getElementById('dotColorText').addEventListener('input', (e) => {
            const color = e.target.value;
            if (/^#[0-9A-F]{6}$/i.test(color)) {
                document.getElementById('dotColor').value = color;
            }
        });

        document.getElementById('showDebug').addEventListener('change', (e) => {
            const debugDiv = document.getElementById('debugInfo');
            if (!e.target.checked) {
                debugDiv.style.display = 'none';
            }
        });

        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tab).classList.add('active');
            
            if (tab !== 'scanner' && stream) {
                stopCamera();
            }
        }

        function stringToBinary(str) {
            let binary = '';
            for (let i = 0; i < str.length; i++) {
                let bin = str.charCodeAt(i).toString(2);
                binary += bin.padStart(8, '0');
            }
            return binary;
        }

        function binaryToString(binary) {
            let str = '';
            for (let i = 0; i < binary.length; i += 8) {
                let byte = binary.substr(i, 8);
                if (byte.length === 8) {
                    const charCode = parseInt(byte, 2);
                    if (charCode > 0 && charCode < 128) {
                        str += String.fromCharCode(charCode);
                    }
                }
            }
            return str;
        }

        function showDebug(info) {
            if (document.getElementById('showDebug').checked) {
                const debugDiv = document.getElementById('debugInfo');
                debugDiv.style.display = 'block';
                debugDiv.innerHTML = info;
            }
        }

        function distributeBits(binary, mode, cols, rows) {
            const totalCells = cols * rows * 2;
            const paddedBinary = binary.padEnd(totalCells, '0');
            
            let topBits = [];
            let bottomBits = [];
            
            switch(mode) {
                case 'split':
                    // –ü—Ä–æ—Å—Ç–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ø–æ–ø–æ–ª–∞–º
                    const halfPoint = Math.ceil(paddedBinary.length / 2);
                    topBits = paddedBinary.substring(0, halfPoint).split('');
                    bottomBits = paddedBinary.substring(halfPoint).split('');
                    break;
                    
                case 'interleave':
                    // –ß–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ: —á–µ—Ç–Ω—ã–µ –±–∏—Ç—ã –≤–≤–µ—Ä—Ö, –Ω–µ—á–µ—Ç–Ω—ã–µ –≤–Ω–∏–∑
                    for (let i = 0; i < paddedBinary.length; i++) {
                        if (i % 2 === 0) {
                            topBits.push(paddedBinary[i]);
                        } else {
                            bottomBits.push(paddedBinary[i]);
                        }
                    }
                    break;
                    
                case 'zigzag':
                    // –ó–∏–≥–∑–∞–≥: –ø–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –≤–≤–µ—Ä—Ö, –≤—Ç–æ—Ä–∞—è –≤–Ω–∏–∑, –∏ —Ç.–¥.
                    let currentZone = 'top';
                    let bitIndex = 0;
                    
                    for (let i = 0; i < rows * 2; i++) {
                        for (let j = 0; j < cols; j++) {
                            if (bitIndex < paddedBinary.length) {
                                if (currentZone === 'top') {
                                    topBits.push(paddedBinary[bitIndex]);
                                } else {
                                    bottomBits.push(paddedBinary[bitIndex]);
                                }
                                bitIndex++;
                            }
                        }
                        currentZone = currentZone === 'top' ? 'bottom' : 'top';
                    }
                    break;
            }
            
            // –î–æ–ø–æ–ª–Ω—è–µ–º –Ω—É–ª—è–º–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            const targetLength = cols * rows;
            while (topBits.length < targetLength) topBits.push('0');
            while (bottomBits.length < targetLength) bottomBits.push('0');
            
            return {
                top: topBits.join(''),
                bottom: bottomBits.join(''),
                total: paddedBinary
            };
        }

        function generate() {
            const data = document.getElementById('data').value;
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const dotMinSize = parseInt(document.getElementById('dotMinSize').value);
            const dotMaxSize = parseInt(document.getElementById('dotMaxSize').value);
            const bgColor = document.getElementById('bgColor').value;
            const dotColor = document.getElementById('dotColor').value;
            const textSize = parseInt(document.getElementById('textSize').value);
            const showGrid = document.getElementById('showGrid').checked;
            const distributionMode = document.getElementById('distributionMode').value;

            if (!data) {
                alert('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è!');
                return;
            }

            const binary = stringToBinary(data);
            const cols = gridSize;
            const rows = Math.ceil(gridSize / 2);
            const totalCells = cols * rows * 2;
            
            // –î–æ–±–∞–≤–ª—è–µ–º –¥–ª–∏–Ω—É –¥–∞–Ω–Ω—ã—Ö –≤ –Ω–∞—á–∞–ª–æ (16 –±–∏—Ç)
            const lengthBinary = binary.length.toString(2).padStart(16, '0');
            const fullBinary = lengthBinary + binary;

            if (fullBinary.length > totalCells) {
                alert(`–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –¥–∞–Ω–Ω—ã—Ö! –ú–∞–∫—Å–∏–º—É–º ${Math.floor((totalCells - 16) / 8)} —Å–∏–º–≤–æ–ª–æ–≤. –£–≤–µ–ª–∏—á—å—Ç–µ —Ä–∞–∑–º–µ—Ä —Å–µ—Ç–∫–∏.`);
                return;
            }
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Å–µ–≤–¥–æ-—Å–ª—É—á–∞–π–Ω—ã–µ –±–∏—Ç—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å ~65% –¥–ª—è –µ–¥–∏–Ω–∏—Ü, —á—Ç–æ–±—ã –≤–∏–∑—É–∞–ª—å–Ω–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ
            function generatePseudoRandomBits(length, seed) {
                let result = '';
                let random = seed;
                for (let i = 0; i < length; i++) {
                    random = (random * 1103515245 + 12345) & 0x7fffffff;
                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 99, –µ—Å–ª–∏ < 65, —Ç–æ —Å—Ç–∞–≤–∏–º 1
                    const value = random % 100;
                    result += (value < 65) ? '1' : '0';
                }
                return result;
            }
            
            // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —è—á–µ–π–∫–∏ –ø—Å–µ–≤–¥–æ-—Å–ª—É—á–∞–π–Ω—ã–º–∏ –±–∏—Ç–∞–º–∏
            const remainingCells = totalCells - fullBinary.length;
            const pseudoBits = generatePseudoRandomBits(remainingCells, data.length);
            const paddedBinary = fullBinary + pseudoBits;

            // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º –±–∏—Ç—ã –º–µ–∂–¥—É –∑–æ–Ω–∞–º–∏ (–≤–∫–ª—é—á–∞—è –ø—Å–µ–≤–¥–æ-—Ç–æ—á–∫–∏)
            const distributed = distributeBits(paddedBinary, distributionMode, cols, rows);

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const size = 600;
            canvas.width = size;
            canvas.height = size;

            const centerX = size / 2;
            const centerY = size / 2;
            
            // –°–æ–∑–¥–∞–µ–º –∫—Ä—É–≥–ª—É—é –º–∞—Å–∫—É –¥–ª—è –≤—Å–µ–≥–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ
            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, size / 2, 0, Math.PI * 2);
            ctx.clip();
            
            // –§–æ–Ω –∫—Ä—É–≥–∞
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, size, size);

            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —à—Ä–∏—Ñ—Ç–∞ –¥–ª—è –∏–∑–º–µ—Ä–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–∞
            ctx.fillStyle = dotColor;
            ctx.font = `bold ${textSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const textMetrics = ctx.measureText('BE THE LIGHT');
            const textWidth = textMetrics.width;

            // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –º–∞—Ä–∫–µ—Ä–æ–≤
            const markerRadius = 12;
            const markerGap = 25;
            const markerX1 = centerX - textWidth / 2 - markerRadius - markerGap;
            const markerX2 = centerX + textWidth / 2 + markerRadius + markerGap;

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–æ–Ω—ã –¥–ª—è —Ç–æ—á–µ–∫
            const textHeight = textSize * 1.2;
            const textTop = centerY - textHeight / 2;
            const textBottom = centerY + textHeight / 2;
            
            const topZoneStart = 50;
            const topZoneEnd = textTop - 20;
            const topZoneHeight = topZoneEnd - topZoneStart;
            
            const bottomZoneStart = textBottom + 20;
            const bottomZoneEnd = size - 50;
            const bottomZoneHeight = bottomZoneEnd - bottomZoneStart;
            
            const gridWidth = size * 0.88; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –¥–æ 88% –¥–ª—è –±–æ–ª–µ–µ –∫—Ä—É–≥–ª–æ–π —Ñ–æ—Ä–º—ã
            const gridStartX = centerX - gridWidth / 2;
            const cellWidth = gridWidth / cols;
            const cellHeightTop = topZoneHeight / rows;
            const cellHeightBottom = bottomZoneHeight / rows;

            const dots = [];
            let topDotsCount = 0;
            let bottomDotsCount = 0;

            // –†–∏—Å—É–µ–º —Å–µ—Ç–∫—É –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞ - –ï–î–ò–ù–ê–Ø —Å–µ—Ç–∫–∞ –ø–æ –≤—Å–µ–º—É –∫—Ä—É–≥—É
            if (showGrid) {
                ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                ctx.lineWidth = 0.5;
                ctx.setLineDash([2, 2]);
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–±—â—É—é –æ–±–ª–∞—Å—Ç—å —Å–µ—Ç–∫–∏
                const fullGridTop = 50;
                const fullGridBottom = size - 50;
                const fullGridHeight = fullGridBottom - fullGridTop;
                const fullGridLeft = 50;
                const fullGridRight = size - 50;
                const fullGridWidth = fullGridRight - fullGridLeft;
                
                // –†–∞–∑–º–µ—Ä —è—á–µ–π–∫–∏
                const totalRows = rows * 2; // –í–µ—Ä—Ö + –Ω–∏–∑
                const cellHeight = fullGridHeight / totalRows;
                const cellWidth = fullGridWidth / cols;
                
                // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –ø–æ –≤—Å–µ–π —à–∏—Ä–∏–Ω–µ
                for (let row = 0; row <= totalRows; row++) {
                    const y = fullGridTop + row * cellHeight;
                    ctx.beginPath();
                    ctx.moveTo(fullGridLeft, y);
                    ctx.lineTo(fullGridRight, y);
                    ctx.stroke();
                }
                
                // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –ø–æ –≤—Å–µ–π –≤—ã—Å–æ—Ç–µ
                for (let col = 0; col <= cols; col++) {
                    const x = fullGridLeft + col * cellWidth;
                    ctx.beginPath();
                    ctx.moveTo(x, fullGridTop);
                    ctx.lineTo(x, fullGridBottom);
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
            }

            ctx.fillStyle = dotColor;

            // –í–µ—Ä—Ö–Ω—è—è –∑–æ–Ω–∞
            let topBitIndex = 0;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (topBitIndex >= distributed.top.length) break;
                    
                    const x = gridStartX + col * cellWidth + cellWidth / 2;
                    const y = topZoneStart + row * cellHeightTop + cellHeightTop / 2;
                    
                    const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    if (distFromCenter > size / 2 - 20) {
                        topBitIndex++;
                        continue;
                    }
                    
                    if (distributed.top[topBitIndex] === '1') {
                        const dotSize = dotMinSize + Math.random() * (dotMaxSize - dotMinSize);
                        ctx.beginPath();
                        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                        ctx.fill();
                        dots.push({ x, y, size: dotSize, bit: 1, zone: 'top', row, col });
                        topDotsCount++;
                    } else {
                        dots.push({ x, y, size: 0, bit: 0, zone: 'top', row, col });
                    }
                    
                    topBitIndex++;
                }
            }

            // –ù–∏–∂–Ω—è—è –∑–æ–Ω–∞
            let bottomBitIndex = 0;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (bottomBitIndex >= distributed.bottom.length) break;
                    
                    const x = gridStartX + col * cellWidth + cellWidth / 2;
                    const y = bottomZoneStart + row * cellHeightBottom + cellHeightBottom / 2;
                    
                    const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    if (distFromCenter > size / 2 - 20) {
                        bottomBitIndex++;
                        continue;
                    }
                    
                    if (distributed.bottom[bottomBitIndex] === '1') {
                        const dotSize = dotMinSize + Math.random() * (dotMaxSize - dotMinSize);
                        ctx.beginPath();
                        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                        ctx.fill();
                        dots.push({ x, y, size: dotSize, bit: 1, zone: 'bottom', row, col });
                        bottomDotsCount++;
                    } else {
                        dots.push({ x, y, size: 0, bit: 0, zone: 'bottom', row, col });
                    }
                    
                    bottomBitIndex++;
                }
            }

            // –ë–æ–∫–æ–≤—ã–µ –∑–æ–Ω—ã - –∏—Å–ø–æ–ª—å–∑—É–µ–º –¢–£ –ñ–ï —Å–µ—Ç–∫—É —á—Ç–æ –∏ –¥–ª—è –≤—Å–µ–≥–æ –∫—Ä—É–≥–∞!
            const fullGridTop = 50;
            const fullGridLeft = 50;
            const fullGridRight = size - 50;
            const totalRows = rows * 2;
            const fullGridHeight = (size - 50) - fullGridTop;
            const fullGridWidth = fullGridRight - fullGridLeft;
            const globalCellHeight = fullGridHeight / totalRows;
            const globalCellWidth = fullGridWidth / cols;
            
            const leftZoneEnd = markerX1 - markerRadius - 10;
            const rightZoneStart = markerX2 + markerRadius + 10;
            const sideZoneHeight = textHeight;
            const sideZoneTop = centerY - sideZoneHeight / 2;
            const sideZoneBottom = centerY + sideZoneHeight / 2;
            
            let leftDotsCount = 0;
            let rightDotsCount = 0;
            
            // –õ–µ–≤–∞—è –±–æ–∫–æ–≤–∞—è –∑–æ–Ω–∞ - –ø–æ –≤—Å–µ–π –≤—ã—Å–æ—Ç–µ –∫—Ä—É–≥–∞
            for (let row = 0; row < totalRows; row++) {
                const y = fullGridTop + row * globalCellHeight + globalCellHeight / 2;
                
                for (let col = 0; col < cols; col++) {
                    const x = fullGridLeft + col * globalCellWidth + globalCellWidth / 2;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ø–∞–¥–∞–µ—Ç –ª–∏ —ç—Ç–∞ —è—á–µ–π–∫–∞ –≤ –ª–µ–≤—É—é –∑–æ–Ω—É (—Å–ª–µ–≤–∞ –æ—Ç –ª–µ–≤–æ–≥–æ –º–∞—Ä–∫–µ—Ä–∞)
                    if (x >= leftZoneEnd) continue;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç–∞ –ª–∏ —ç—Ç–∞ —è—á–µ–π–∫–∞ –≤–µ—Ä—Ö–Ω–µ–π/–Ω–∏–∂–Ω–µ–π –∑–æ–Ω–æ–π
                    // –í–µ—Ä—Ö–Ω—è—è –∏ –Ω–∏–∂–Ω—è—è –∑–æ–Ω—ã –∑–∞–Ω–∏–º–∞—é—Ç –¶–ï–ù–¢–†–ê–õ–¨–ù–£–Æ —á–∞—Å—Ç—å –ø–æ —à–∏—Ä–∏–Ω–µ
                    const inTopZone = (y >= topZoneStart && y <= topZoneEnd && x >= gridStartX && x <= gridStartX + gridWidth);
                    const inBottomZone = (y >= bottomZoneStart && y <= bottomZoneEnd && x >= gridStartX && x <= gridStartX + gridWidth);
                    if (inTopZone || inBottomZone) continue;
                    
                    const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    if (distFromCenter > size / 2 - 20) continue;
                    
                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Å–µ–≤–¥–æ-—Å–ª—É—á–∞–π–Ω—ã–π –±–∏—Ç
                    const randomBit = Math.random() < 0.65 ? 1 : 0;
                    
                    if (randomBit === 1) {
                        const dotSize = dotMinSize + Math.random() * (dotMaxSize - dotMinSize);
                        ctx.beginPath();
                        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                        ctx.fill();
                        dots.push({ x, y, size: dotSize, bit: 1, zone: 'left', row, col });
                        leftDotsCount++;
                    } else {
                        dots.push({ x, y, size: 0, bit: 0, zone: 'left', row, col });
                    }
                }
            }
            
            // –ü—Ä–∞–≤–∞—è –±–æ–∫–æ–≤–∞—è –∑–æ–Ω–∞ - –ø–æ –≤—Å–µ–π –≤—ã—Å–æ—Ç–µ –∫—Ä—É–≥–∞
            for (let row = 0; row < totalRows; row++) {
                const y = fullGridTop + row * globalCellHeight + globalCellHeight / 2;
                
                for (let col = 0; col < cols; col++) {
                    const x = fullGridLeft + col * globalCellWidth + globalCellWidth / 2;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ø–∞–¥–∞–µ—Ç –ª–∏ —ç—Ç–∞ —è—á–µ–π–∫–∞ –≤ –ø—Ä–∞–≤—É—é –∑–æ–Ω—É (—Å–ø—Ä–∞–≤–∞ –æ—Ç –ø—Ä–∞–≤–æ–≥–æ –º–∞—Ä–∫–µ—Ä–∞)
                    if (x <= rightZoneStart) continue;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç–∞ –ª–∏ —ç—Ç–∞ —è—á–µ–π–∫–∞ –≤–µ—Ä—Ö–Ω–µ–π/–Ω–∏–∂–Ω–µ–π –∑–æ–Ω–æ–π
                    // –í–µ—Ä—Ö–Ω—è—è –∏ –Ω–∏–∂–Ω—è—è –∑–æ–Ω—ã –∑–∞–Ω–∏–º–∞—é—Ç –¶–ï–ù–¢–†–ê–õ–¨–ù–£–Æ —á–∞—Å—Ç—å –ø–æ —à–∏—Ä–∏–Ω–µ
                    const inTopZone = (y >= topZoneStart && y <= topZoneEnd && x >= gridStartX && x <= gridStartX + gridWidth);
                    const inBottomZone = (y >= bottomZoneStart && y <= bottomZoneEnd && x >= gridStartX && x <= gridStartX + gridWidth);
                    if (inTopZone || inBottomZone) continue;
                    
                    const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    if (distFromCenter > size / 2 - 20) continue;
                    
                    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Å–µ–≤–¥–æ-—Å–ª—É—á–∞–π–Ω—ã–π –±–∏—Ç
                    const randomBit = Math.random() < 0.65 ? 1 : 0;
                    
                    if (randomBit === 1) {
                        const dotSize = dotMinSize + Math.random() * (dotMaxSize - dotMinSize);
                        ctx.beginPath();
                        ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                        ctx.fill();
                        dots.push({ x, y, size: dotSize, bit: 1, zone: 'right', row, col });
                        rightDotsCount++;
                    } else {
                        dots.push({ x, y, size: 0, bit: 0, zone: 'right', row, col });
                    }
                }
            }

            // –ú–∞—Ä–∫–µ—Ä—ã
            ctx.strokeStyle = dotColor;
            ctx.fillStyle = bgColor;
            ctx.lineWidth = 2.5;
            
            // –õ–µ–≤—ã–π –º–∞—Ä–∫–µ—Ä
            ctx.beginPath();
            ctx.arc(markerX1, centerY, markerRadius + 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = dotColor;
            ctx.beginPath();
            ctx.arc(markerX1, centerY, markerRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(markerX1, centerY, markerRadius * 0.5, 0, Math.PI * 2);
            ctx.stroke();

            // –ü—Ä–∞–≤—ã–π –º–∞—Ä–∫–µ—Ä
            ctx.fillStyle = bgColor;
            ctx.beginPath();
            ctx.arc(markerX2, centerY, markerRadius + 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = dotColor;
            ctx.beginPath();
            ctx.arc(markerX2, centerY, markerRadius, 0, Math.PI * 2);
            ctx.stroke();

            // –¢–µ–∫—Å—Ç
            ctx.fillStyle = dotColor;
            ctx.font = `bold ${textSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('BE THE LIGHT', centerX, centerY);
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç (—É–±–∏—Ä–∞–µ–º clipping)
            ctx.restore();
            
            // –†–∏—Å—É–µ–º –æ–±–≤–æ–¥–∫—É –∫—Ä—É–≥–∞ –ø–æ–≤–µ—Ä—Ö –≤—Å–µ–≥–æ
            ctx.strokeStyle = dotColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, size / 2 - 1, 0, Math.PI * 2);
            ctx.stroke();

            currentCode = {
                data: data,
                binary: fullBinary,
                distributed: distributed,
                gridSize: { cols, rows },
                dots: dots,
                size: size,
                mode: distributionMode
            };

            // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏
            const distInfo = document.getElementById('distributionInfo');
            distInfo.style.display = 'block';
            const realDataBits = fullBinary.length;
            const pseudoBitsCount = paddedBinary.length - fullBinary.length;
            const totalOnes = (paddedBinary.match(/1/g) || []).length;
            const realOnes = (fullBinary.match(/1/g) || []).length;
            const pseudoOnes = totalOnes - realOnes;
            const fillPercent = ((totalOnes / paddedBinary.length) * 100).toFixed(1);
            
            const totalDotsAll = topDotsCount + bottomDotsCount + leftDotsCount + rightDotsCount;
            
            distInfo.innerHTML = `
                <strong>üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è (${distributionMode}):</strong><br>
                –í–µ—Ä—Ö–Ω—è—è –∑–æ–Ω–∞: ${topDotsCount} —Ç–æ—á–µ–∫<br>
                –ù–∏–∂–Ω—è—è –∑–æ–Ω–∞: ${bottomDotsCount} —Ç–æ—á–µ–∫<br>
                –õ–µ–≤–∞—è –∑–æ–Ω–∞: ${leftDotsCount} —Ç–æ—á–µ–∫<br>
                –ü—Ä–∞–≤–∞—è –∑–æ–Ω–∞: ${rightDotsCount} —Ç–æ—á–µ–∫<br>
                <strong>–í—Å–µ–≥–æ —Ç–æ—á–µ–∫: ${totalDotsAll}</strong><br>
                <br>
                –†–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: ${realDataBits} –±–∏—Ç (${data.length} —Å–∏–º–≤–æ–ª–æ–≤ + 16 –±–∏—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫) ‚Üí ${realOnes} —Ç–æ—á–µ–∫<br>
                –ü—Å–µ–≤–¥–æ-–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ: ${pseudoBitsCount} –±–∏—Ç ‚Üí ${pseudoOnes} —Ç–æ—á–µ–∫<br>
                –ë–æ–∫–æ–≤—ã–µ –∑–æ–Ω—ã: ${leftDotsCount + rightDotsCount} —Ç–æ—á–µ–∫ (–¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω–æ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ)<br>
                –û–±—â–∏–π —Ä–∞–∑–º–µ—Ä: ${paddedBinary.length} –±–∏—Ç
            `;

            // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            const debugInfo = `
                <strong>DEBUG INFO</strong><br>
                ================<br>
                Data: "${data}"<br>
                Length: ${data.length} chars<br>
                Binary: ${fullBinary.length} bits<br>
                Grid: ${cols}√ó${rows}<br>
                Mode: ${distributionMode}<br>
                ----------------<br>
                Top zone: ${topDotsCount} dots<br>
                Bottom zone: ${bottomDotsCount} dots<br>
                Total dots: ${topDotsCount + bottomDotsCount}<br>
                ----------------<br>
                Top bits: ${distributed.top.substring(0, 32)}...<br>
                Bottom bits: ${distributed.bottom.substring(0, 32)}...
            `;
            showDebug(debugInfo);

            document.getElementById('downloadBtn').style.display = 'block';
        }

        function download() {
            const canvas = document.getElementById('canvas');
            const link = document.createElement('a');
            link.download = 'be-the-light-code.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        async function startCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                const video = document.getElementById('video');
                video.srcObject = stream;
                video.style.display = 'block';
                video.play();
                scanning = true;
                
                captureInterval = setInterval(captureAndScan, 2000);
            } catch (err) {
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ: ' + err.message);
            }
        }

        function stopCamera() {
            scanning = false;
            if (captureInterval) {
                clearInterval(captureInterval);
            }
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            document.getElementById('video').style.display = 'none';
        }

        function captureAndScan() {
            const video = document.getElementById('video');
            const canvas = document.getElementById('scanCanvas');
            const ctx = canvas.getContext('2d');

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                canvas.classList.add('show');
                
                scanImage(canvas);
            }
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.getElementById('scanCanvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    canvas.classList.add('show');
                    
                    scanImage(canvas);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function scanImage(canvas) {
            showProgress('üîç –ò—â—É –∫—Ä—É–≥–ª—ã–µ –º–∞—Ä–∫–µ—Ä—ã...', 10);

            try {
                const markers = findCircleMarkers(canvas);
                
                if (!markers || markers.length < 2) {
                    showProgress('‚ùå –ú–∞—Ä–∫–µ—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã', 100);
                    displayResult('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∫—Ä—É–≥–ª—ã–µ –º–∞—Ä–∫–µ—Ä—ã. –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –∫–æ–¥ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–∏–¥–µ–Ω.', false);
                    return;
                }

                showProgress('‚úÖ –ú–∞—Ä–∫–µ—Ä—ã –Ω–∞–π–¥–µ–Ω—ã! –î–µ–∫–æ–¥–∏—Ä—É—é...', 50);
                console.log('–ù–∞–π–¥–µ–Ω—ã –º–∞—Ä–∫–µ—Ä—ã:', markers);

                const decodedData = decodeFromMarkers(canvas, markers);
                
                if (decodedData) {
                    showProgress('‚úÖ –£—Å–ø–µ—à–Ω–æ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–æ!', 100);
                    displayResult(decodedData, true);
                    stopCamera();
                } else {
                    showProgress('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å', 100);
                    displayResult('–î–∞–Ω–Ω—ã–µ –Ω–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ª—É—á—à–µ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ.', false);
                }
            } catch (err) {
                console.error('–û—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è:', err);
                showProgress('‚ùå –û—à–∏–±–∫–∞', 100);
                displayResult('–û—à–∏–±–∫–∞: ' + err.message, false);
            }
        }

        function findCircleMarkers(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            const circles = [];
            const threshold = 200;
            const step = 10;
            
            for (let y = step; y < canvas.height - step; y += step) {
                for (let x = step; x < canvas.width - step; x += step) {
                    let whiteCount = 0;
                    const radius = 20;
                    
                    for (let dy = -radius; dy <= radius; dy += 5) {
                        for (let dx = -radius; dx <= radius; dx += 5) {
                            if (dx*dx + dy*dy <= radius*radius) {
                                const idx = ((y + dy) * canvas.width + (x + dx)) * 4;
                                if (data[idx] > threshold && data[idx+1] > threshold && data[idx+2] > threshold) {
                                    whiteCount++;
                                }
                            }
                        }
                    }
                    
                    if (whiteCount > 30) {
                        circles.push({ x, y, confidence: whiteCount });
                    }
                }
            }
            
            circles.sort((a, b) => b.confidence - a.confidence);
            return circles.slice(0, 2);
        }

        function decodeFromMarkers(canvas, markers) {
            console.log('üîç –ù–∞—á–∏–Ω–∞–µ–º –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ...');
            
            try {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–µ–Ω—Ç—Ä –ø–æ –º–∞—Ä–∫–µ—Ä–∞–º
                const marker1 = markers[0];
                const marker2 = markers[1];
                const centerX = (marker1.x + marker2.x) / 2;
                const centerY = (marker1.y + marker2.y) / 2;
                const markerDistance = Math.sqrt(Math.pow(marker2.x - marker1.x, 2) + Math.pow(marker2.y - marker1.y, 2));
                
                console.log(`üìç –¶–µ–Ω—Ç—Ä: (${centerX.toFixed(0)}, ${centerY.toFixed(0)})`);
                console.log(`üìè –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –º–∞—Ä–∫–µ—Ä–∞–º–∏: ${markerDistance.toFixed(0)}px`);
                
                // 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–∞–∑–º–µ—Ä –∫—Ä—É–≥–∞ –∏ —Å–µ—Ç–∫–∏
                const circleRadius = canvas.width / 2;
                const gridSize = 20; // cols
                const rows = 10;
                const totalRows = rows * 2;
                
                // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–µ—Ç–∫–∏ (–¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º)
                const fullGridTop = circleRadius * 0.1;
                const fullGridBottom = canvas.height - circleRadius * 0.1;
                const fullGridHeight = fullGridBottom - fullGridTop;
                const fullGridLeft = circleRadius * 0.1;
                const fullGridRight = canvas.width - circleRadius * 0.1;
                const fullGridWidth = fullGridRight - fullGridLeft;
                
                const cellHeight = fullGridHeight / totalRows;
                const cellWidth = fullGridWidth / gridSize;
                
                console.log(`üìê –°–µ—Ç–∫–∞: ${gridSize}√ó${totalRows}, —è—á–µ–π–∫–∞: ${cellWidth.toFixed(1)}√ó${cellHeight.toFixed(1)}`);
                
                // 3. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–æ–Ω—ã
                const textHeight = canvas.height * 0.1; // –ü—Ä–∏–º–µ—Ä–Ω–∞—è –≤—ã—Å–æ—Ç–∞ —Ç–µ–∫—Å—Ç–∞
                const textTop = centerY - textHeight / 2;
                const textBottom = centerY + textHeight / 2;
                
                const topZoneStart = fullGridTop;
                const topZoneEnd = textTop - 20;
                const bottomZoneStart = textBottom + 20;
                const bottomZoneEnd = fullGridBottom;
                
                const gridWidth = canvas.width * 0.88;
                const gridStartX = centerX - gridWidth / 2;
                
                // 4. –ß–∏—Ç–∞–µ–º —Ç–æ—á–∫–∏ –∏–∑ –≤–µ—Ä—Ö–Ω–µ–π –∏ –Ω–∏–∂–Ω–µ–π –∑–æ–Ω
                let topBits = '';
                let bottomBits = '';
                
                // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞–ª–∏—á–∏—è —Ç–æ—á–∫–∏ –≤ —è—á–µ–π–∫–µ
                function hasDot(x, y, radius = 10) {
                    let whitePixels = 0;
                    let totalPixels = 0;
                    
                    for (let dy = -radius; dy <= radius; dy += 2) {
                        for (let dx = -radius; dx <= radius; dx += 2) {
                            if (dx*dx + dy*dy <= radius*radius) {
                                const px = Math.round(x + dx);
                                const py = Math.round(y + dy);
                                
                                if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                                    const idx = (py * canvas.width + px) * 4;
                                    const brightness = (data[idx] + data[idx+1] + data[idx+2]) / 3;
                                    
                                    if (brightness > 200) whitePixels++;
                                    totalPixels++;
                                }
                            }
                        }
                    }
                    
                    return totalPixels > 0 && (whitePixels / totalPixels) > 0.3;
                }
                
                // –ß–∏—Ç–∞–µ–º –≤–µ—Ä—Ö–Ω—é—é –∑–æ–Ω—É
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const x = gridStartX + col * cellWidth + cellWidth / 2;
                        const y = topZoneStart + row * (topZoneEnd - topZoneStart) / rows + ((topZoneEnd - topZoneStart) / rows) / 2;
                        
                        const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                        if (distFromCenter > circleRadius - 20) {
                            topBits += '0';
                            continue;
                        }
                        
                        topBits += hasDot(x, y) ? '1' : '0';
                    }
                }
                
                // –ß–∏—Ç–∞–µ–º –Ω–∏–∂–Ω—é—é –∑–æ–Ω—É
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const x = gridStartX + col * cellWidth + cellWidth / 2;
                        const y = bottomZoneStart + row * (bottomZoneEnd - bottomZoneStart) / rows + ((bottomZoneEnd - bottomZoneStart) / rows) / 2;
                        
                        const distFromCenter = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                        if (distFromCenter > circleRadius - 20) {
                            bottomBits += '0';
                            continue;
                        }
                        
                        bottomBits += hasDot(x, y) ? '1' : '0';
                    }
                }
                
                console.log(`üìä –ü—Ä–æ—á–∏—Ç–∞–Ω–æ –±–∏—Ç–æ–≤: –≤–µ—Ä—Ö=${topBits.length}, –Ω–∏–∑=${bottomBits.length}`);
                
                // 5. –°–æ–±–∏—Ä–∞–µ–º –±–∏—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
                // –ü—Ä–æ–±—É–µ–º —Ä–µ–∂–∏–º interleave (—á–µ—Ä–µ–¥–æ–≤–∞–Ω–∏–µ)
                let fullBinary = '';
                for (let i = 0; i < Math.max(topBits.length, bottomBits.length); i++) {
                    if (i < topBits.length) fullBinary += topBits[i];
                    if (i < bottomBits.length) fullBinary += bottomBits[i];
                }
                
                console.log(`üìù –ü–æ–ª–Ω–∞—è —Å—Ç—Ä–æ–∫–∞: ${fullBinary.length} –±–∏—Ç`);
                console.log(`üî¢ –ü–µ—Ä–≤—ã–µ 32 –±–∏—Ç–∞: ${fullBinary.substring(0, 32)}`);
                
                // 6. –ß–∏—Ç–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –¥–ª–∏–Ω—ã (–ø–µ—Ä–≤—ã–µ 16 –±–∏—Ç)
                const lengthBinary = fullBinary.substring(0, 16);
                const dataLength = parseInt(lengthBinary, 2);
                
                console.log(`üìè –î–ª–∏–Ω–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞: ${dataLength} –±–∏—Ç`);
                
                if (dataLength <= 0 || dataLength > fullBinary.length - 16) {
                    console.error('‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –¥–ª–∏–Ω–∞ –¥–∞–Ω–Ω—ã—Ö');
                    return null;
                }
                
                // 7. –ß–∏—Ç–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                const dataBinary = fullBinary.substring(16, 16 + dataLength);
                console.log(`üì¶ –î–∞–Ω–Ω—ã–µ: ${dataBinary.length} –±–∏—Ç`);
                
                // 8. –î–µ–∫–æ–¥–∏—Ä—É–µ–º –≤ —Ç–µ–∫—Å—Ç
                const decodedText = binaryToString(dataBinary);
                console.log(`‚úÖ –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–æ: "${decodedText}"`);
                
                return decodedText;
                
            } catch (error) {
                console.error('‚ùå –û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è:', error);
                return null;
            }
        }

        function showProgress(message, percent) {
            const progressDiv = document.getElementById('scanProgress');
            progressDiv.innerHTML = `
                <div class="progress">
                    <div>${message}</div>
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${percent}%"></div>
                    </div>
                </div>
            `;
        }

        function displayResult(data, success) {
            const resultDiv = document.getElementById('scanResult');
            resultDiv.className = 'scanner-result ' + (success ? 'success' : 'error');
            resultDiv.innerHTML = `
                <strong>${success ? '‚úÖ –£—Å–ø–µ—à–Ω–æ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–æ!' : '‚ùå –û—à–∏–±–∫–∞'}</strong>
                <div class="result-text">${data}</div>
            `;
        }
    </script>
</body>
</html>
